python学习笔记;

1变量;
    变量可想象为一个容器,这是一种抽象的描述,
    它是一种抽象的容器,可以装东西的就是容器,如包,碗,罐,柜等等,
    即-器皿.
    注释和运算符,
    有#和'''与"""三种符号表示,
    加减乘除+-*/,乘是星号*不是埃克斯X,
    取余%,取模商//,幂运算**两个星号,
    星号*还可以重复输出字串.用*乘以次数.
    
    命名,
    有python的PEP风格,空格要多使用,缩进要规范,
    注意数字类0-9和非数字类(如字符)的不同表示,
    可下划线_开始,不能数字0-9开始,
    直观和顾名思义,直达根本含义的原则,
    
    数据类型,
    整数int,浮点float,字符串str,布尔bool(真假.1/0),
    数字类0-9和非数字类,
    
    输出与输入,
    print()函数与input()函数的活用,
    为了减少中转变量的使用(节省计算机资源和空间)
    可以嵌套调用功能函数和print()与input()的互动,
    互相嵌套使用,
    函数运算后的结果需要用一个变量去存储.
    
    格式化输出[%]号,
    整数d%,浮点f%,字符串s%,
    %前面放数字表示有几位,小数用.小数点,0就表示有几个0,
    还需要和变量连接,%后跟变量,
    2个以上变量可用()括号,%号后面跟括号,可运算,
    输出百分号用两个%%.
    
TA们不愿动手做,就等着别人做好给ta,

2分支;
    分支可想象为岔路,岔路有很多种,两岔,三岔,四岔,类推.
    判断;
      if若,如果,假如,假设,
      生活中充满各种选择,程序亦如此,选择分支后的行为.
      选择之前要判断,用if若,和else否则,elseif那么,
      条件成立,成立后的行为,
      条件不成立,不成立后的行为,
      代码块概念,属于if的判断地盘的都在一个代码块里,
      如果要判断的条件太长,可以用括号()括起来,然后手动换行.
      语法;
        if 要判断的条件 :  (不能少了冒号)
            条件成立后的行为  (必须要缩进,4个空格)
            
        else :  (不能少了冒号)
            条件不成立后的行为
            
        变体;
        if 要判断的条件:
              成立的语句
        elif 条件:
              成立的语句
        elif 条件:
              成立的语句 
        else:
              不成立的语句
              
        if嵌套;
        在前一级条件满足的情况下,再度细判.
        if嵌套需要注意else悬挂的问题,
        if 条件:
            要执行的语句
            if 条件:
                要执行的语句
                    if 条件:
                        要执行的语句
                    else:
                        不满足条件的语句
            else:
                  不满足条件的语句            
        else:
            不满足条件的语句
            
    运算符;
      比较(关系)运算符,
      等于,不等于,大于,小于,大等,小等,
      ==,!=,>,<,>=,<=,中间不能隔开.
      
     
    逻辑运算符,
      与and,读作并且,
      或or,读作或者,
      非not,读作不是,
      将条件组,合在一起组成复合条件块. 
      拼接复杂逻辑计算条件,
      小技巧;可以在注释里先分解分析下逻辑关系. 
      
    赋值运算符,
      赋值,=,
      加赋+=, 减赋-=, 乘赋*=, 除赋/=, 取商赋//=,
      取余赋 %=,幂赋**=,
      两个符合必须紧密,不能有空格.
      
    随机数;
      random的使用.下限必须小于上限.

计算机里都是数字,完全可以用中文汉字汉语来表示一切的,比如用几位二进制如00001代表1,用1代表'一',也可以用1代表'one',当你输入'一'或'one'的时候,在计算机里先转化为整数1,然后再转化为二进制00001.同理可证,00010就可代表2,用2代表二或two,00011就可代表3,用3代表三或three,这个二进制用多少位怎么编码,是00001或001或010代表1还是10000代表1,还是00100代表1,这个需要契约或者说标准,这需要委员会一样的组织开会讨论.自然的,也就可以用中文汉字汉语来编程,写程序,但经过我的仔细查阅和研究,发现有相当一部分跪族跪奴跪舔西方的人是逢中必反.TA们会诉诸多借口来反驳中文不适合编程,在计算机界还存在有相当多的人留有废除汉字思想.在计算机界没有民族责任感国家责任感的人太多了,你就看他支不支持中文汉字汉语编程即见分晓.
并且中文汉字汉语是象形文字,对传导[意]的能力是明显强于字母文字的,因为每个汉字就是一张图,具备高阶抽象的能力,而且用中文汉字汉语的人一个字一个音,记忆字只需记忆字形,并且直观,如水在甲骨文上就是表示流动的液态,看水这个字,立即理解到是流动的水液,就代表这个意思,而water是什么?你看这个字母组合并不能立即理解它指代流动的液态这个意思,也就是说单个汉字就是被看做最小原子化.而字母文字却不是这样,像abcxyz这些只是一个个字母,TA们还需要组合在一起才能被称为'字'即word,举例,w和e,分开只是字母(笔画),合在一起we才能表示'我',也就是说单个字母只相当于咱们中文汉字汉语的某一笔画,你用英文键盘打英语其实只是在写笔画罢了,而咱们的五笔,是以字的结构和形状,即字根来作为最小不可分割的部分,当然五笔只是中文汉字汉语在信息输入时的一种解决方案,或许还有更优的方法尚待后人去创造,而基于字母的文明,词汇和字,语言和文字,界线模糊,但咱中文汉字汉语却不是这样,字就是字,词就是词,有明确界定,用中文汉字汉语去编写程序,可读性将非常高,表达力,代码复用,抽象能力等都是一座巨大的宝库,明显强于西文字母文字的.人脑处理图形图像的速度要远远快于其它信息载体的方式,所以,象形文字的优势还没被发掘出来. 
经过细思,我发现了一件细思极恐的事.
number(号码),digital(数字),data(数据)
既然计算机是数字计算机,也就是说,一切皆可被数字替代,那为何又会出现西文字母文字字符表示一切的情况呢,有些人会用'因为计算机是西方人发明的'一言以蔽之,但情况真的是这样吗.
还有编码的问题,比如字符编码,经过仔细查阅,我发现没有一种编码是真正出自咱们人手里的,如ASCII,Unicode等,全是西方人主导的,别人表面上说是兼容全球,其实别人很是勉为其难.即便是咱们自己制定的GBK编码,也是在ASCII上改的,也就是说,咱们完全没有一款以数字计算机原理为基础设计的字符编码.
由此可见要创造出中文汉字汉语编程,甚至创造生态,到底是一件多么艰难的事,但令人无奈的事实就是,当前咱国的软件生态几乎都是被一群意志薄弱的弱者懦夫占领着高地.TA们根本不会迎难而上去解决这个问题.真正会想要创造中文汉字汉语编程的热心同胞大多都是极为艰难地在负重前行,并且这些同胞数量很少,屈指可数,也就可见咱们的力量之弱小.
并且从中可以窥探出西方人的险恶用心,比如十六进制,既然是数字计算机,为何表示10到15的时候用abcdef,为何不用数字,并且,为何要搞出16进制来?一切都是跟西方人自身自私生存利益有关,TA们从来就没想过别的种群的生存需求,毕竟是狩猎文明而不是农耕文明,源头如此.但更令人不解的就是不但不反思,还附和西方的自以为是的那群意志薄弱的懦夫了,这可以说明这种汉奸思想的具体汉奸过程.
既然是数字计算机,阿拉伯数字又没有版权和知识产权的问题可言,我认为很有必要从程序的角度重新定义计算机从底层到高阶抽象的字符表示体系.有利于咱国人的一套规则.否则以ASCII,Unicode,GBK的编码规范来看,咱中文汉字汉语永远是三等公民(一等美,二等欧,三等亚非拉),难道大伙儿希望咱的文化永远处于劣等劣势状态吗?永远自己以三等公民自居吗,永远低人一等咱的文化是别人文化的奴隶,进而咱们的人也比别人低人一等永世为奴吗.不!起码我不承认!我就要想办法去改变这个现状.
字符根本不是直接转换到二进制去编码的,而是要经过数字编码,我以前也论证过这个,那么也就是说,从二进制0101010到→数字1234567890这两层的表达可以做到绝对公有化,而从数字到某国的使用的文字符号体系的编码,这个咱现在是完全有能力重新设计的.经过我查阅,我发现咱中文汉字汉语不管是在Unicode还是UTF(8 16 32)中都是三等公民,特别是UTF8,这无形中在贬低咱们的文化宿主-文字.
由此也感慨道,要办成中文汉字汉语编程(编程语言,操作系统,编译器,生态)这件事,果然绝非是一两个热心的同胞没日没夜废寝忘食瞎搞就能做到的,毕竟,咱们讲的文化自信,也不是几个热心同胞的责任吧.那么,最好还是组织一下群众,壮大开发的力量,建立标准委员会才是第一步.人员散漫,力量分散,这就是当前的状况.拖沓,怠慢,惰慢,怠惰.

3循环;
    循环可想象为圆圈,环形,球形,
    程序有三大流程,顺序,分支,循环.
    顺序,从上往下,一条条以此按顺序执行.
    分支,根据条件进行判断,选择判断后的某一分支,
    循环,选择特定的代码按需要的条件和次数重复执行.
    
    while 循环用法,
    初始条件(次数控制始)计数器
    while 判断条件:(次数控制判断)结束界限,
        满足条件执行
        步进条件(步进次数控制)计数器
        
    计数的方法和计数的习惯,
    日常自然习惯从1开始计数,
    程序世界习惯从0开始计数,
    非特殊需求的话,默认都从0开始计数.    
    
    变量在循环内进行判断后会产生分支,虽然变量名还是那个名
    但在内存中已经是存储不同的结果(不可见),就像平行宇宙一样,
    循环内的判断内的分支和循环内判断外的分支,计算结果不一样,
    但变量名却可以一样.
    
    break和continue;
    循环内控制循环过程的功能关键字,
    只对当前所在的循环体内的代码有效,
    break;中断,跳出.
    当某一所需条件满足时,断开与后续重复代码的接力,
    并退出循环,
    continue;继续,
    有时,因为仅仅满足某一具体细小的单独条件,
    而不执行那一次循环,
    但整个循环内之后的重复条件还得继续执行下去直到完成,
    continue只是为了排除整个循环内某一个特定的条件,
    在跳过的那一次和下一次之间执行continue的代码,
    
    
    注意,如果循环中使用了continue功能,需要在其前面紧凑放置
    处理这一次重复的次数控制代码,否则会引起死循环,
    #continue[继续]相当于跳过这一次循环,即不执行这一次,
    #但总体循环没停止,
    #那样的话,这一重复的判断分支内就永远在跳过这一次判断,
    #而整个循环体的计数器又永远不停地在推进剩下的次数,
    #直到循环次数的条件满足才结束,那么就会一直停滞,
    #满足预设的停滞条件就会在循环体中一直停滞,
    #于是形成死循环,
    #所以要在continue前面放置加一次的控制.把跳过的补上,
    
    循环嵌套;
    在一个循环体内包含另一个循环体,可多级嵌套,如,
    初始
    while 满足条件判断: 
        执行业务代码
        {初始
        while 满足条件判断: 
            执行业务代码
            {初始
            while 满足条件判断:
                执行业务代码
                步进}
            步进}     
        步进
    
    print函数默认情况下自动换行,如果不希望这样做,可以在其
    参数列最后增加 end="" ,引号中可显示需要输出的内容,   
    
    转义字符;
    在字符串内部使用的特殊字符,这个字符在向控制台输出的时候
    被转义为另一个特殊的符号,这个符号代表的含义由对应的
    转义字符确定,
    反斜杠开头,\,
    \\,\',\",\t,\n, \r,
    \\转义反斜杠到控制台显示, \',\"转义引号到控制台显示,
    \t转义一个制表到控制台显示,python里是对齐,
    \n转义一个手动换行到控制台输出,
    \r转义回车到控制台输出,只输出字符串中转义之后的,


以上为每门编程语言的基本功(不同语言有若干出入),
或者说语言所提供的功能的最细分每个知识点,    
-------------------------------------------------------
以下为将离散的每个细分功能点进行组织整合后的
复合功能体,这其中有一定的结构,


4函数;
    函数可想象为一个盒子,盒子有一个进口和一个出口,
    进口只能进,出口只能出,
    模块就可想象为一个工具包,
    而函数就是这个工具包中的一个工具,  
    简而言之,函数就像是一个增加了手脚和触手的容器,
    
    所谓函数,就是将不可细分的各种独立的最小功能组件
    组织为一个小型的复合功能体,它本质上也是一个容器,
    但却是一个复合的容器,是将不同的容器经由预设的结构
    紧密组织而成,在需要的时候,即可唤其名字来调用之,
    此即为:代码复用.
    定义函数,将独立功能封装为复合容器,封装可理解为打包,
    调用函数,将已经封装好的复合功能体直接拿来用,
    函数的益处即为提高编码的效率和代码重复用,
    
    语法格式;
    def 函数名():
        构成函数功能体的代码 (注意开头要缩进)
        
    函数名的起名原则为见名知意,顾名思义,名称应该能直观地
    表示此函数携带了那些功能体,函数名的命名规则与变量名
    相同,    
    注意,函数定义好后,只相当于给这个盒子里装了一些东西,
    只是把有结构的功能体装进去而已,它相对来说是静态的,
    需要主动调用它才会被执行, 主动才会显示出动态性, 
    函数必须服从先定义后使用的规则,定义体要在执行名之前,
    函数的注释和说明可以放在函数功能体内的"""或'''之中,
    因为函数是个相对独立的存在,所以最好在函数功能体外与
    别的代码隔开两行以示区别.
    
    函数参数;
    可以想象为是盒子的进入口,
    函数只能处理预设固定的数值,要处理动态的数据,需要通过
    参数传递给功能体执行,结果将自动返回给调用者,
    
    函数,把具有独立功能的代码块组织为一个小模块,在需要
    的时候调用之,
    函数的参数,增加函数的通用性,针对相同的数据处理逻辑,
    能够适应更多的数据,
      在函数内部,把参数当做变量使用,
      当函数被调用时,按照函数定义的参数顺序,让希望函数功能体
      处理的数据通过参数传递进去,
      
    形参和实参;
    形式参数和实际参数,顾名思义,
    形参,定义函数时,在小括号中用于接收外部传来的参数,属于
    函数内部的变量.
    实参,函数被调用时,在小括号中用于传递给函数功能体使用
    的中间介质, 函数内部处理的是这个实实在在的数据值,
    
    函数的返回值;
    函数返回值可以想象为是盒子的出口,
    如果希望函数执行完后给调用者一个结果,这就是函数的返回值,
    用return关键字可以代表函数的输出,调用者需要另建一个变量
    接收return返回的结果,
    函数内部return下一行之后的代码不会被执行,返回了值
    即为结束,
    
    函数的嵌套调用;
    函数调用函数,即为函数的嵌套调用,
    一个函数内部调用了另一个函数,
    程序的执行线路,当遇到调用函数时就跳转到被调用的函数那儿,
    执行被调用的那个函数,完事后,回到调用者,有值把值给调用者,
    继续顺序执行后面的代码,
    函数的调用线路,调用函数后,当前状态停留在函数执行时,执行
    完后状态返回到上一个调用者处,
    传参数可以增加灵活性,需求快速变化时可以通过传参灵活变通.
    实际开发作业时,需冷静分析变化的需求,不要随意更改能
    正常执行的已定义好的函数功能体,抓住变化的重点针对解决,
    灵活性和通用性,是函数设计和参数传递的优先考虑,
    建议函数内部可变数据均改成参数便于外部调用者传参进入,
    
    
5模块;
    模块是python程序结构的一个核心概念,
    模块可以想象为工具包,若需使用这个工具包中的工具,
    需要在源代码头部 import(导入)这个模块,每一个扩展名为
    .py 的python源代码文件都是一个模块,在模块中定义的
    全局变量,函数 都是模块能提供给外界直接可使用的工具, 
    简而言之,模块是以文件的形式来对封装好的代码归类,
    在另一个文件中 import导入 一个模块后,就可以使用
    模块名.变量, 模块名.函数 的形式使用被导入的模块的变量和
    函数,模块可以让曾经编写过的代码方便地复用而无需复制粘贴
    模块名也是一个标示符,命名规则同变量名.
    .pyc 文件是模块编译为字节码的文件,
    
    
6高级变量类型;
    列表,字典,元组,集合,字符串,
    数据类型分,数字型和非数字型.
    数字型就是前面讲过的整数型,浮点型,布尔型,复数型,
    而非数字型就是此知识点,
    变量的高级话题,
    
    公共方法,所有非数字型都支持以下特点,
    1,都是一个序列 sequence,所谓序列就是排成一串的内容,
      也可想象为是一个按不同形式排列的容器,
      字符串是一个个的字符连成一起形成的串,
    2,取值 []
    3,遍历 for in
    4,计算长度,最大/最小值,比较,删除,
    5,链接 + 和 重复 *
    6,切片,  
    
    列表;
      列表可想象为是一个可以放多个东西的容器,为了方便管理
      容器中装的数据,可以给容器划分出一个个独立的小格子,
      即一个萝卜一个坑,每一个小格子对应一个数据,每个小格子
      都有数字编号,编号从 零0 开始,容器中的东西依次类推地编号,
      列表可以存储不同类型的数据,
      
      列表 list 是python中使用最频繁的数据类型,其它语言一般用
      数组 来形容.
      它是专门用来存储一串信息的,一个变量存储多个数据,它用[]
      定义,数据之间用 , 逗号 分隔.
      列表的索引从 0零 开始,索引就是数据在列表中的位置编号,
      索引又可以被称为下标,如果在取值时,超出索引范围会被报错,
      
      定义一个列表变量: 列表名 = []
      
      列表的控制,常用操作,即[增删改查取存]都有相应的内置方法.
      取值,格式: 列表名[编号/索引/下标]
      增加,列表名.insert(索引,数据),列表名.append(数据),
        列表名.extend(列表名n),
        
      删除,列表名.remove[数据],列表名.pop,列表名.clear,
        del 列表名[索引],列表名.pop(索引),
        
      排序,列表名.sort(),列表名.reverse(),
        列表名.sort(reverse=True) 
        
      修改,列表名[索引] = 数据,列表名.copy,
      查询,列表名.index,      
      统计,列表名.count(数据),len(列表名)
      
      点. 后面跟的是方法名,
      方法与函数非常类似,其区别是,函数通过函数名调用,而方法
      是先给一个变量名,后面跟一个 点. 再跟随一个具体方法名
      来调用, 列表名.  之后按Tab键可弹出列表的全部方法,
      
      del 本来作用是将一个变量从内存中删除的,如果使用
      del关键字删除变量,后续开发代码中不能继续使用被删的变量
      在日常开发中,删除列表元素,建议使用列表提供的方法,
      
      关键字/函数/方法,之区别;
      print(keyword.kwlist) 关键字后面不需要跟括号,
      关键字表示特殊含义的标示符.
      函数和方法需要跟括号,括号里放参数,
      函数名(参数), 对象.方法名(参数), 
      方法需要通过对象来调用,表示针对这个对象要做得操作,
      函数需要死记硬背,方法不需要死记硬背.
      
      循环遍历;
      遍历就是从头到尾依次从列表中获取数据,
      在循环体内部针对每一个元素执行相同的操作,
      py专门提供迭代iteration遍历来提高遍历效率,
      用关键字for实现迭代遍历.
      for 变量 in 列表:
        print(变量)
        
    元组;
    元组可想象为是一个可以放多个东西的容器,但存进去的
    东西后就不能修改.
    tuple 元组与列表list类似,但元组中的元素不能被修改.
    元组表示多个元素组成的序列.用于存储一串信息.
    元组用 () 小括号定义,从0开始索引.
    元组亦可保存不同类型的数据.
    若元组中只有一个元素,需要加一个 ,逗号后跟一个空格,
    否则解释器会判定为变量而非元组.
    取索引;已知具体数据,但想知道该数据在什么位置.
    元组有两个方法  .index取索引  .count计数
    
    元组的应用场景; 作为函数的参数和返回值.
    格式化字符串 %() 本质上是一个元组,
    不能被修改的本质可以保证数据安全.
    
    元组与列表之间进行转换,
    元转列; list(元组) , 列转元; tuple(列表)
    
    字典;
    字典可想象为是一个可以放多个东西的容器,每个东西都以双数
    二元标示.可以想象为一个盖子和一个罐子为一组.
    dictionary是除列表外最灵活的数据类型,
    字典亦可储存多个数据,通常用于存储
    描述一个 物体 的相关信息,
    和列表的区别是;
    列表是有序的对象集合,字典是无序的对象集合,
    字典用 {}大括号 定义, 使用 键值对 存储数据,
    键值对之间用 ,逗号 隔开,一个键值对放一行,
    键key 是索引, 值value 是数据, 键与值之间用 :冒号 隔开,
    键必须是唯一的,值可以取任意数据类型,
    键只能使用字符串 数字 元组,
    
    不管是列表还是元组还是字典,
    取值的方法都是对象名后面跟 [] 中括号,
    修改和删除,都是先指定 键 ,然后再使用方法和相应的操作,
    字典的方法;
    len(字典) 获取字典的键值对数量,
    字典.keys() 所有key键列表,
    字典.values() 所有value值列表,
    字典.items() 所有 (key,value) 元组列表,
    字典[key]  ,字典.get(key) 可以从字典中取值,
    del 字典[key] ,字典.pop(key) 删除指定键值对,
    字典.popitem() 随机删除一个键值对,
    字典.clear() 清空字典,
    字典[key] = value 如果key存在,修改数据,否则,新建键值对,
    字典.setdefault(key,value) 如果key存在,不会修改数据,否则,
    新建键值对,
    字典.update(字典2) 将字典2的数据合并到当前字典.如果
    被合并的字典中有相同的键值对,会覆盖原来的键值对,
     
    无论列表元组字典都用中括号[]取值.
    
    循环遍历;
    遍历就是依次从字典中获取所有键值对,
    #for 循环内部使用的 'key 的变量' in 字典
    for 变量 in 字典:
      print(变量,字典[变量])
      
    日常开发中的应用场景;
    尽管可以使用for in遍历字典,但实际开发中,更多的应用场景,
    是使用多个键值对,存储描述一个物件的相关信息,
    即描述更复杂的数据信息.将多个字典放在一个列表中,再进行
    遍历,在循环体内部针对每个字典做相同的处理,
    列表变量 = [{键:值,键:值,键:值},{键:值,键:值,键:值}]  
    
    字符串的定义;
    字符串就是一串字符,在编程中表示文本的数据类型.
    用一堆双引号"或一堆单引号'定义一个字符串.
    大多数编程语言用"双引号定义字符串.
    len(字符串) 获取字符串的长度.
    字符串.count(字符串) 小(子)字符串在大字符串中出现的次数.
    字符串[索引] 从字符串中取出单个字符.
    字符串.index(字符串) 获得小(子)字符串第一次出现的索引.
    字符串的内置方法非常多,可以根据查阅后灵活操作促进需求,
    
    字符串的切片;
    列表元组也适用,
    切片使用索引值来确定范围,从一个大的字符串中切出小字符串,
    字符串[开始索引:结束索引:步长] 正序,从左到右,逆序,从右到左,
    从哪里开始切到哪里结束,注意方向,逆序需要加 -负号,加零到尾
    
    公共方法;
    字符串,列表,元组,字典都可以使用的方法.
    内置函数;
    len(项目) del(项目) max(项目) min(项目) cmp(项目1,项目2) 
    项目.extend() 会合并到项目, 项目.append() 会追加在项目后,
    加号'+'合并, 星号'*'重复,
    > >= < <=  == 也用于比较元素,返回布尔值,
    成员运算符;
    in 与  not in 用于测试序列中是否包含指定的成员,返回布尔值,
    
    完整的for 循环语法;
    for 变量 in 集合:
            循环体代码
    else:
            没有通过break退出循环,循环结束后会执行的代码,
    如果循环体内部使用了break,
    else下方的代码就不会被执行,   


但最好的有助于缓解眼睛疲劳的解决办法仍是把眼睛离开屏幕。限制看屏幕的时间是眼科医生的首要建议。你也可以利用20-20-20规则：每隔20分钟，看20英尺（6米）外的东西20秒钟。
此外，将屏幕高度调整到与眼睛同一水平或低于眼睛。当屏幕高于眼睛时会让眼睛更加干燥。


7综合应用--名片管理系统;
  想象为这是开始用砖块一点点地堆砌和搭建起自己需要的建筑,
  
  系统需求;
  1,程序启动,显示欢迎界面和功能菜单,
  2,用户用数字选择不同的功能,
  3,根据功能选择,执行不同的功能,
  4,用户名片需要记录用户的,姓名,电话,QQ,邮件,
  5,如果查询到指定的名片,用户可以选择修改或删除名片,
  
  综合应用已经学习过的知识点开发需求程序,
  变量,流程控制,函数,模块,
  
  步骤;
  1,框架搭建,
  2,新增名片,
  3,显示所有名片,
  4,查询名片,
  5,查询成功后修改和删除名片,
  6,让python程序能直接运行,
  
  经验;
  
  框架搭建;
  搭建项目[名片管理系统]的框架结构,
  一,准备文件,确定文件名,保证能够 在需要的位置 编写代码,
          1,准备主入口文件,相当于是纲目,提纲,目录.
          2,准备功能文件,相当于是预设计划中每个功能的具体实现,
          新建 卡的主入口.py 保存主程序功能代码,
                  程序的主入口,
                  每次启动此程序都通过主入口这个文件启动,
          新建 卡的工具.py 保存所有名片功能函数,
                  将名片的 新增, 查询,修改,删除 等功能
                  封装在不同的函数里,
  二,编写 主运行循环,实现基本的 用户输入和判断,
          在 卡的主入口 中添加一个无限循环,由用户主动决定
          什么时候退出循环,
          
          卡的主入口.py
          while True:
                  # TODO(小明) 显示系统菜单
                  活动 = int(input("请选择功能:")) 
                  print("你选择的是: %d" % 活动) 
                  
                  #根据用户输入决定后续的操作
                  if 活动 == 1:
                          pass
                  elif 活动 == 2:
                          pass
                  else:
                          print("你输入错误,重新选")
  
  如果要开发一个系统,需要搭建一个框框和架子,
  也就是 [匠] 的奥义,需要准备箩筐与斧子,当框框和架子准备完成
  以后,就能以框架为基础,不断地扩充和完善,也就是积累和累积,
  直到实现项目预先计划的所有目标.
  并且普遍情况下,大多数时候都分为两部分,
  一是功能组织(代码主结构),二是功能实现(代码副结构),
  先确定框架和数据结构,不要急着编写一个个功能,
  先写注释,分析和明确步骤,找思路,
  
  如果在开发程序时,不希望立刻编写分支内部的代码,
  可以使用 pass 关键字,表示一个占位符,能保证程序的
  代码结构正确,程序运行时,pass 不会执行任何操作,
  
  无限循环;
  在程序开发时,如果不希望程序执行后立即退出,可以在程序中
  增加一个无限循环,由用户来决定退出程序的时机,
  
  TODO 注释;
  团队协作时可用,
  在#井号后跟上TODO去做,用于标记需要去做的工作,
  例; # TODO(谁? 作者/邮件) 显示系统菜单,
  
  保存名片数据的结构;
  程序就是用来处理数据的,而变量就是用来存储数据的,
          使用字典存储每一张名片的详细信息,
          使用列表统一存储所有的名片字典,
  定义名片列表变量,
          在 卡的工具.py 文件的顶部增加一个列表变量,
          #所有名片存储的列表,
          卡的列表 = [] 
          
  #return关键字 可以返回函数的执行结果,还有,它下方的
  代码不会被执行,如果return后面没有表达式,它会返回到调用
  函数的位置,且不返回任何结果,
  
  卡的工具.py
  新建一个列表用于存储多张名片,
  显示菜单---用print函数打印出需要显示的字符串,
  新增名片---将名片的每个项目保存到单独的变量中,
                      然后将变量保存到字典(的键值对中)或列表中,
                      用append方法将字典添加到名片列表中,
  显示名片---先判断名片列表中是否存储有名片,
                      然后用for循环输出名片表头,
                      再用for循环在名片列表中遍历每个名片,
  搜索名片---建一个变量保存用户想查找的名片,
                      保存input输入的值, 
                      for循环遍历的方式在名片列表中搜索
                      名片,用if判断用户输入的名片与列表中
                      的名片是否相等,True就做格式化输出,
                      
                      新建函数用于处理修改,删除,返回的
                      子功能,然后将存储名片各项目的字典  
                      做参数传入这个新建函数中,
  处理名片字典所在的卡片---新建变量用于
                      存储 [1]修改,[2]删除,[0]返回,用户
                      的选择,用input接收用户输入的字串,
                      使用if elif判断变量中的值,
                      如果是[1]修改,就给名片字典的每个键值对
                      赋新值,字典使用 []中括号 访问'键',
                      如果是[2]删除,就用名片列表调用remove方法
                      将欲删除的名片字典传参进入来移除那张名片,
                      如果是[0]返回,就自动返回到上一层调用处,
                      
                      新问题;本函数无法跳过无需修改的字典键值,
                      因此需要再新建一个函数用于处理需要修改的
                      和不需要修改的,用以扩展原有函数无法实现的功能
  处理输入卡片信息---需要传两个参数,参一字典原有的值,
                      参二提示用户输入的文字,
                      新建一个变量存储提示输入的文字,
                      if 判断len(变量)是否大于0
                      (注;大于零代表是否是有效输入)
                      如果 True真 就 return返回 这个变量,
                      else否则 return返回 字典原有值,
                      
                      
  在Linux和UNIX上运行脚本文件类程序;
  1通过添加#!符号在脚本文件开头执行,
  Linux上的 shebang 符号(#!),
  #!符号叫做 shebang 或 sha-bang;
  shebang通常在UNIX系统脚本中的第一行开头使用,
  指明执行这个脚本文件的解释程序,
  
   在终端输入 which python3 查找解释器路径,
   在脚本文件 脚本文件名.py 第一行输入查找到的路径,
   如  #! /usr/bin/python3 ,
   修改脚本文件的执行权限 chmod +x 脚本文件名.py  ,
   执行 ./脚本文件名.py  ,
   
  2通过指定具体解释器执行,
  如python脚本就在终端输入  python3 脚本文件名.py 
  其它脚本语言程序执行方式类似,
  
  
8变量进阶(理解);
  目标;
  变量的引用,
  可变与不可变类型,
  局部变量和全局变量,
  
  1变量的引用;
  变量 和 数据 都保存在 内存 中,大多数情况下指
  操作系统的逻辑内存,在py中函数的参数传递以及返回值都是靠
  引用传递的,
    引用的概念,在py中,
    变量和数据 是分开存储的,数据保存在内存中的一个独立位置,
    变量中保存着数据在内存中的地址,
    变量中记录数据的地址这个动作,就叫做 引用,
    使用 id() 函数可以查看变量中保存数据所在的内存地址,
    注:如果变量已经被定义,当给一个变量赋值的时候,本质上
    是修改了数据的引用,
    变量 不再 对之前数据引用,变量 改为 对新赋值的数据引用,
    
    看到赋值语句,首先把注意力放在等号的右侧,
    如a=1,形象地把存储1的内存空间想象为一个坑儿,格子,即容器,
    而变量a用来记录1所在内存空间的内存地址,通过a即可访问
    到数据1, a → |1|  这个箭头→就可看做是引用,
    在py中,我们可以把变量的引用行为看做是一张便签纸,
    把数据存放的空间看做是一个小格子,
    
    变量引用的示例,演练,
    在py中,变量的名字类似于便签纸贴在数据上,
    定义一个整数变量a,并且赋值为1,
    >>> a = 1
    >>> id(a)
    8791580238480(表示内存地址)
    >>> id(1)
    8791580238480(表示内存地址)
    >>> b = a
    >>> id(b)
    8791580238480(表示内存地址)
    >>> a = 2
    >>> id(a)
    8791580238512(表示内存地址)
    >>> id(2)
    8791580238512(表示内存地址)
    >>> id(b)
    8791580238480(表示内存地址)
    >>> b = a
    >>> id(b)
    8791580238512(表示内存地址)
    
  函数的参数和返回值的传递;
  函数的 实参/返回值 都是靠引用来传递的,
  
  #数据的地址本质上就是一串数字
  调用函数时,会把参数(变量)的地址传递到函数内,
  #调用函数时,本质上传递的是实参保存数据的引用,
  而不是实参保存的数据,
  #注意,如果函数有返回值,但没定义变量接收,程序不会报错,
  但无法获得返回结果,
  #函数return返回时,返回的是数据的引用,而不是数据本身,
  
  2可变与不可变类型;
  不可变类型,内存中的数据不允许被修改:
  数字类型 int,bool,float,complex,long(2.x) 
  字符串 str,
  元组 tuple,
  可变类型,内存中的数据可以被修改:
  列表 list,
  字典 dict,
  注意,字典key键只能使用不可变类型的数据,
  可变类型的数据变化,是通过方法来实现的,
  如果给一个可变类型的变量,赋值一个新的数据,引用会修改,
  变量 不再 对之前数据引用,变量 改为 对新赋值的数据引用,
  >>> a = [1,2,3]
  >>> id(a)
  58905992(表示内存地址)
  >>> a.append(999)
  >>> a
  [1, 2, 3, 999]
  >>> id(a)
  58905992(表示内存地址)
  >>> a.remove(2)
  >>> a
  [1, 3, 999]
  >>> id(a)
  58905992(表示内存地址)
  >>> a.clear()
  >>> a
  []
  >>> id(a)
  58905992(表示内存地址)
  >>> a = []
  >>> id(a)
  59030024(表示内存地址)
  
  >>> a = {"名":"小明"}
  >>> a
  {'名': '小明'}
  >>> a["龄"] = 18
  >>> a
  {'名': '小明', '龄': 18}
  >>> id(a)
  60479456(表示内存地址)
  >>> a.pop("龄")
  18
  >>> a
  {'名': '小明'}
  >>> id(a)
  60479456(表示内存地址)
  >>> a.clear()
  >>> a
  {}
  >>> id(a)
  60479456(表示内存地址)
  >>> a = {}
  >>> id(a)
  59828408(表示内存地址)
  
  哈希(hash)
  所谓哈希是一个算法,可以理解成一个函数.
  py内置一个名叫 hash(o)的函数,接受一个不可变类型的数据
  作为参数,返回结果是一个整数,
  哈希 是一种算法,其作用就是提取数据的特征码(指纹),相同的
  内容得到相同的结果,不同的内容得到不同的结果,
  在py中,设置字典的键值对时,谁首先对key键进行hash,以决定
  如何在内存中保存字典的数据,好方便后续对字典的操作:
  增, 删, 改, 查,
  键值对的key键必须是不可变类型数据,value值可以是任意类型,
  >>> hash(1)
  1(特征码(指纹))
  >>> hash("你好")
  3442680934912866314(特征码(指纹))
  >>> hash("你好1")
  -8862779320862575137(特征码(指纹))
  >>> hash((1,))
  3430019387558(特征码(指纹))
  
  3局部变量和全局变量;
  局部变量是在函数内部定义的变量,只能在函数内部使用,
  全局变量是在函数外部定义的变量(没有定义在某一个函数内),
  所有函数内部都可使用这个变量,
  注;在其它编程语言中,大多不推荐使用全局变量---可变范围太大,
  导致程序不好维护,
  
  局部变量;
  局部限定在函数内部使用的变量,就叫做局部变量,
  函数内部定义和使用,函数执行结束后,内部的局部变量,会被回收,
  不同的函数,可以定义相同的局部变量名,但各用各的不产生影响,
  局部变量的作用;
  在函数内部使用,临时保存函数内部需要使用的数据,
  局部变量的生命周期;
  所谓生命周期就是变量从被创建到被系统回收的过程,
  局部变量在函数执行时才会被创建,函数执行结束后局部变量被
  系统回收,局部变量在生命周期内,可以用来存储函数内部临时
  使用到的数据, 
  
  全局变量;
  全局都可使用的变量,在函数外部定义的变量,所有函数内部都可
  使用这个变量,注,函数执行时,需要处理变量时会;
  首先查找函数内部是否存在指定名称的局部变量,若有,直接用,
  若没有,查找函数外部是否存在指定名称的全局变量,若有,就用,
  若还没有,程序报错,
  函数不能直接修改全局变量的引用,
  在函数内部,可以通过全局变量的引用获取对应的数据,但是,不允
  许直接修改全局变量的引用---使用赋值语句修改全局变量的值,
  #若使用赋值语句,只会在函数内部定义一个同名的局部变量,
  在函数内部修改全局变量的值;
  若在函数中需要修改全局变量,需要使用global关键字进行声明,
  全局变量定义的位置;
  为了保证所有的函数都能够正确使用到全局变量,应该将
  全局变量定义在其它函数上方,
  #注意,在开发时,应该把模块中的所有全局变量定义在所有
  函数上方,就可以保证所有的函数都能够正常地访问到
  每一个全局变量了,
  
  代码结构示意图如下;
  [shebang]
  [import模块]
  [全局变量]
  [函数定义]
  [执行代码]
  
  全局变量命名的建议;
  为了避免局部变量和全局变量出现混淆,在定义全局变量时,
  有些公司会有一些开发要求,例如;
  全局变量名钱应该增加g_或者gl_的前缀,
  具体的要求格式,各公司可能会有些差异, 
  
  函数参数和返回值的作用;
  函数根据有没有参数,有没有返回值,可以相互组合为4种形式,
  1无参数,无返回值,
  2无参数,有返回值,
  3有参数,无返回值,
  4有参数,有返回值,
  定义函数时,是否接收参数,是否返回结果,根据实际功能需求决定,
  把函数想象为一个有进口和出口的黑盒子,参数为进,返回值为出,
  参数:外界希望在函数内部处理的数据,
  返回值:向外界报告函数的执行结果,
  若函数内部处理的数据不确定,可将外界数据用参数传到函数内,
  若希望某函数执行完后,向外界汇报执行结果,可增加函数返回值,
  
  函数的返回值,进阶;
  有时希望某函数执行后,给调用者结果,以便后续开发,
  返回值是函数完成工作后,最后给调用者的一个结果,
  在函数中用return关键字返回结果,调用者用变量接收返回值,
  
  函数的参数,进阶;
  不可变和可变的参数,
  无论传递的参数是可变还是不可变,只要针对参数使用赋值语句,
  会在函数内部修改局部变量的作用,不会影响到外部变量的引用,
  #在函数内部,针对参数使用赋值语句,
  不会修改到外部的实参变量,
  若传递的参数是可变类型,在函数内部用方法修改了数据的内容,
  同样会影响到外部的数据, 
  
  缺省参数;
  定义函数时,可给某参数指定默认值,这就叫缺省参数,
  调用函数时,若没传入缺省参数的值,则在内部用定义时指定的
  参数默认值,函数的缺省参数,将常见的值设置为参数的缺省值,
  从而简化函数的调用,
  在参数后使用赋值语句,可以指定参数的缺省值,
  缺省参数,需要使用最常见的值作为默认值,
  若一个参数的值不能确定,则不应设为默认值,具体值由外界传入,
  缺省参数的定义位置,必须保证带有默认值参数在参数列表末尾,
  在调用带多个缺省参数的函数时,需指定参数名,明参数对应关系,
  
  多值参数;
  假若需要一个函数能处理的参数个数是不确定的,
  这时就可用多值参数,
  在py中,有两种多值参数,
  参数名前增加一个* 可以接收 元组,
  参数名前增加两个** 可以接收 字典,
  在给多值参数命名时,惯用*args --存放元组参数,前面有一个*,
  惯用**kwargs--存放字典参数,前面有两个**,
  args为arguments的缩写,kw为keyword缩写,可存键值对参数,
  
  元组和字典的拆包;
  调用带多值参数的函数时,若希望将一元组变量传递给args,
  将一字典变量传递给kwargs,
  就可以使用拆包,简化参数的传递,拆包的方式是,
  在元组变量前,增加一个*,在字典变量前,增加两个**,
  一句话讲,就是将指定的 元组/字典 变量各自传递到指定的参数,
  
  函数的递归;
  函数调用自身的 编程技巧 被称为递归,
  它的特点是一个函数在内部调用自己,
  既然可在内部调其它函数,亦可在函数内部调用自己,
  代码特点,
  函数内部代码相同,只是针对参数不同,处理结果就不同,
  当参数满足一个条件时,函数不再执行,这非常重要,通常被称为
  递归的出口,否则,会出现死循环,
  例如;
  def 数字和(数字):
    print(数字)
    #递归的出口,当参数满足某个条件时,不再执行函数,
    if 数字 == 1:  #循环的结束条件,针对参数进行判断,
        return

    #递归就是自己调用自己
    数字和(数字 - 1)  #循环的步进条件,
    print("完成",数字)

  数字和(3)  #循环的开始条件,
  
  温馨提示;
  递归是一个编程技巧,初次接触会感觉艰难,在处理不确定的
  循环条件时,格外地有用,例如,遍历整个文件目录的结构,


9面向对象(OOP)基本概念;
  面向对象可以想象为是对现实世界的模拟,模仿,现实世界的
  结构和物质,逻辑联系关系,像镜像一样映射到面向对象
  程序世界里,
  
  面向对象编程---Object Oriented Programming 简写 OOP,
  面向过程 与 面向对象,是两种不同的编程方式,
  对比面向过程的特点,能更好地了解什么是面向对象,
  过程,是早期的一个编程概念,类似函数,只负责执行而无返回值,
  函数,不仅能执行,还能返回结果,
  基本概念-面向过程;
  1把完成某个需求的 /-所有步骤-/ /-从头到尾-/ 逐步顺序实现,
  2根据需求,将某些功能独立的代码封装成一个又一个函数,
  3最后完成的代码,就是顺序地调用不同的函数,
  特点;
  注重步骤与过程,不注重职责分工,若需求繁复,代码会变得很复杂,
  开发复杂项目,无固定开发流程,开发难度巨大,
  
  基本概念-面向对象;
  相较函数,面向对象是建立在函数之上的抽象,更上层的封装,
  根据职责在一个对象中封装多少个方法(功能独立的代码),
  1在完成某需求前,先确定职责 即/-要做的事情(方法)-/
  2根据职责确定不同[对象],在对象内部封装不同的方法(多个),
  3最后完成的代码,就是顺序地,让不同的对象调用不同的方法,
  特点;
  注重对象和职责,不同对象承担不同职责,适合应对复杂需求变化,
  为专门开发繁复项目而设计的开发流程,面向对象的语法建立在
  面向过程语法之上,
  编程结构建模,
  
  类和对象;
  概念,关系,设计,
  类与对象是面向对象编程两个核心概念,
  类,是对一群具有相同特征或行为之事物的统称,抽象不能直接用,
  特征是属性,行为是方法,
  类,相当于蓝图,建造图纸,负责创建对象的模板,
  #也就是说转化过程为, 想法主意→伪代码→类,
  对象,是由类创造出的具体存在,可直接用,
  由具体指定的类创造出的对象,就会具备这个类定义的属性,方法
  对象,相当于用设计蓝图制造的实物,具象化,
  
  在日常开发中,应该先有类,再有对象,类是模板,对象根据模板创造
  类只有一个,对象可有很多个,
  不同对象之间属性会各不相同,类中定义了什么方法和属性,
  对象中就有什么方法和属性,不可能多,也不可能少,
  
  在用面向对象开发前,首先应分析需求,确定程序需要包含哪些类,
  设计一个类,通常需要满足三个要素,
  1类名,这类事物的名字,满足大驼峰命名法,
  2属性,这类事物具有什么样的特征,
  3方法,这类事物具有什么样的行为,
  类名的确定,
  名词提炼法,分析整个业务流程,通常出现的名词就是要找的类,
  对象的特征描述,通常可定义成属性,
  对象具备的行为(动词),通常可定义为方法,
  
  面向对象基础语法,
  py中,变量 数据 函数皆是对象,
  标示符/数据后的 .运算符,显示能调用的方法列表,
  __方法名__, 两个下划线开始和结束的方法或属性都是py中
  针对对象提供的内置方法/属性.
  dir() 内置函数传入 标示符/数据,可查看所有属性和方法,利用好
  就无需死记硬背各种方法名属性名,
  id() 可查看内存地址,
  
  定义简单的类,只包含方法,
  在py中,方法的定义和函数几乎一样,
  区别在于第一个参数必须是self,
  class 类名:
    def 方法1(self,参数列表):
          pass
    def 方法2(self,参数列表):
          pass
          
  创建对象,
  当一个类定义完成后,若需用这个类创建对象,语法格式如下,
  #等号右侧负责创建对象,等号左侧变量负责对这个对象进行引用
  对象变量 = 类名()   
  
  对象变量.方法1()
  对象变量.方法2()
  
  引用概念的强调,
  引用的概念同样适用于面向对象开发,
  在py中,使用类创建对象后,对象变量中仍然记录的是
  对象在内存中的地址,即对象变量引用了新建的类对象,
  用print输出对象变量,默认是能输出此变量引用的对象是哪一个
  类创建的对象,以及在内存中的地址(十六进制表示) 
  注,在计算机里,通常使用十六进制表示内存地址,
  %d 输出十进制数字, %x 输出十六进制数字,
  
  self方法;
  某对象调用的方法,方法内的self就是某对象的引用,
  在类封装的方法内部,self表示当前调用方法的对象它自己,
  类外部调用方法时,无需传递self参数,
  在方法内部,可以用self.访问对象属性,亦可调用其他对象方法,
  注,不推荐在类的外部给对象增加属性,
  对象需要的属性,应封装在类的内部,
  
  初始化方法;
  当使用 类名() 创建对象时,会自动执行以下操作,
  1为对象在内存中分配空间---创建对象,
  2为对象的属性设置初始值---初始化方法(init)
  此初始化方法就是 __init__方法,它是对象的内置方法,
  它是专门用来定义一个类具有哪些属性的方法,
  在初始化方法内部定义属性,
  在__init__方法内部用 self.属性名 = 属性的初始值 定义属性,
  定义完后,使用类创建的对象,都会拥有该属性,
  初始化的同时设置初始值,创建对象的同时就设置对象的属性,
  1将欲设置的属性值,定义成__init__方法的参数,
  2在方法内部用 self.属性 = 形参 接收外部传递的参数,
  3在创建对象时,用 类名(属性1,属性2...)调用,
  所谓方法就是封装在类内部的函数,方法的语法跟函数的语法
  是完全一样的,
  __del__内置方法,
  当一个对象被从内存中销毁前,会自动调用__del__方法,
  对象生命周期开始于创建 类名() 并调用时,
  对象生命周期结束于 __del__ 方法被调用时,
  __str__内置方法,
  若在开发中,想用print输出对象变量时,能够打印自定义的内容,
  就可利用__str__这个内置方法,它必须 return返回 一个字符串,
  
  面向对象的封装;
  1封装是面向对象编程的一大特点,
  2面向对象编程的第一步--将属性和方法封装到一个抽象的类中
  3在类外部使用类创建对象,然后让对象调用方法,
  4对象能调用的方法的细节都被封装在类的内部,
  在对象来自类的方法之内部,可以直接访问对象在类中的属性,
  同一个类创建的多个对象之间,属性互不干涉,
  通常应该先写被使用的类, 什么使用什么,
  一个从类创建的对象之属性,可以是另外一个类创建的对象,
  小结,
  主程序只负责创建各个类的对象,
  让对象调用类的方法将需求的项目处理到类中,
  各种操作-计算-业务流程-业务逻辑等处理都被封装到类的内部,
  定义没有初始值的属性,
  若初始值未知,可以用None设置,
  None关键字表示什么都没有,表示一个空对象,没有方法和属性,
  是一个特殊的常量,可以将None赋值给任何一个变量,
  
  身份运算符 is / is not;
  此运算符用于比较两个对象的内存地址是否一致,
  是否是对同一个对象的引用,针对None比较时,建议用 is 判断,
  is 与 == 的区别,
  is 用于判断两个变量引用对象是否为同一个,     比对地址,
  == 用于判断引用变量的值是否相等,          比对地址里的数据,
  
  私有属性和私有方法;
  私有属性和私有方法就是对象不希望公开的属性和方法,
  实际开发时,对象的某些属性或方法只希望在对象的内部被使用,
  不希望在外部被访问到,
  定义属性或方法时,在属性名或方法名前,
  增加 两个下划线__  定义的就是  __私有  属性与方法,
  伪私有,
  在私有属性与方法前加一个下划线后跟类名,
  _类名__属性名,_类名__方法名    此方法可以访问私有,
  但在日常开发中,不推荐使用这种破坏隐私方式,py中没有真正
  意义的私有,它只是在命名时,对名称做特殊处理,使得外界无法
  访问,
  
  继承;
  继承可想象为仿生遗传,仿物造化,
  单继承,多继承,
  面向对象是建立在函数 结构体 指针之上,具有超越性的组织法,
  对象和类,属性和方法,继承和多态,
  
  
  面向对象三大特性, 封装,继承,多态,
  实现代码的重用,相同代码无需重复编写,此为继承,
  增加代码灵活度,不同对象调用相同方法,出不同执行结果, 多态,
  
  单继承;
  继承的概念 语法 特点,
  概念,子类拥有父类的所有方法和属性,子类继承自父类,可以
  直接享受父类中已经封装好的方法,无需再次开发,
  子类亦可根据职能,封装子类特有的专有属性和方法,
  语法;
  class 子类名(父类名):
            pass                                              
  继承的传递性,c继b继a,c具备b和a的所有属性和方法,
  孙子拥有父亲和爷爷的所有基因特点和财富资产,
  方法的重写;
  当父类的方法不能满足子类需要时,可以对方法重写(override)
  重写父类方法有两种情况,
  1覆盖父类的方法,   2对父类方法进行扩展,
  具体现实是在子类中定义一个与父类中同名的方法并实现,
  重写后,运行时只会调用子类中重写的方法,不再调父类封装的,
  
  若子类方法实现中包含父类方法实现,父类原本的是子类方法
  的一部分,就可以使用扩展的方式,在子类中重写,
  在需要的位置使用 super().父类方法 来调用父类方法执行,
  其它位置针对子类需求,编写子类特有的代码实现.
  关于super,
  在py中,它是一个特殊的类,
  super() 就是用super类创建出来的对象,
  最常使用场景就是,重写父类方法时,调用父类中封装的方法实现
  
  另一种调用父类方法,
  父类名.方法(self)
  不推荐使用,易混乱,若用当前子类名调用方法,会递归并死循环,
  
  父类的私有属性和方法,
  子类对象不能在自己的方法内部直接访问父类的私有属性和方法
  子类对象可以通过父类的公有方法间接访问到私有属性和方法,
  私有属性与方法是对象的隐私,不公开,外界和子类都不能访问,
  
  多继承;
  子类可以有多个父类,并具有所有父类的属性和方法,
  例,孩子会继承自己父亲和母亲的特性,
  后代会遗传所有先代的基因和习惯和资产, 
  语法;
  class 子类名(父类名1,父类名2.....) 
            pass
  注,若父类之间存在同名的属性或方法,应尽量避免使用多继承,
  开发时,若不同父类存在同名方法,子类对象如何调用?
  应避免容易产生混淆的情况.
  在py中,类提供了内置属性__mro__,可查看方法方案秩序,
  MRO,方法方案秩序,用于多继承判断方法属性调用路径,
  
  新式类与旧式类(经典类),
  object是py为所有对象提供的基类,它有一些内置方法和属性,
  新式类,以object为基类的类,推荐使用,
  经典类,不以object为基类的类,
  class 类名(object)
            pass
  在py3中定义类,默认用object作为该类的基类,
  新式类和经典类在多继承时,会影响方法的搜索顺序,即MRO,
  
  
  多态;
  封装-定义类的准则,继承-设计类的技巧,多态-调用方法的技巧,
  多态增加灵活性,以继承和重写父类方法为前提,
  它是调用方法的技巧,不会影响到类的内部设计,
  不同的子类对象调用相同的父类方法,产生不同的执行结果,
  
  类的结构,术语-实例,
  1用面向对象开发,第一步是设计类,
  2使用 类名() 创建对象,一在内存中为对象分配空间,
  二调用初始化方法__init__为对象初始化,
  3对象创建后,内存中就有一个对象实实在在的存在---实例,
  因此,通常把创建出来的对象叫做类的实例,对象的动作叫实例化
  对象的属性叫做实例属性,
  每一个对象都有自己独立的内存空间,保存各自不同的属性,
  多个对象的方法,在内存中只有一份,调用方法时,需要把
  对象的引用传递到方法内部,
  
  类是一个特殊的对象,
  python中,一切皆对象,
  程序运行时,类同样被加载到内存,类对象在内存中只有一份,
  使用一个类能创多个实例,
  类属性就是给类定义的属性,用于记录与此类相关的特性,
  属性的获取机制,
  获取存在一个向上查找的机制,访问类属性有两方式,
  1类名.类属性,    2对象.类属性(不推荐), 
  类方法就是针对类对象定义的方法,
  在类方法内部可以直接访问类属性,调用其他类方法,
  语法;
  @classmethod
  def 类方法名(cls):
        pass
  类方法需用修饰器@classmethod来标示,告诉解释器这是一个
  类方法,它的第一个参数应该是cls,
  由某类调用的方法,其内的cls就是某类的引用,
  这个参数和实例方法的第一个参数self类似,
  通过类名. 调用类方法,调用时无需传递cls参数,
  在方法内部,可用 cls. 访问类属性,亦可调用其它类方法,
  静态方法,
  无需访问[实例属性,类属性],无需调用[实例方法,类方法],
  语法;
  @staticmethod
  def 静态方法名():
        pass
  静态方法需用修饰器@staticmethod来标示,通过 类名. 调用,
  
  定义方法时,如何确定[实例属性,类属性]与[实例方法,类方法]?
  若方法内部需访问实例属性,即可定义方法为实例方法,
  实例方法用 类名. 访问类属性,
  若方法内部只需访问类属性,即可定义方法为类方法,
  若方法内部的实例属性和类属性都无需访问,
  即可定义方法为静态方法,
  
  单例;
  单例设计模式,
  "设计模式,是前人工作的总结和提炼,通常被人们广为流传的某
  设计模式都是针对某一特定问题的成熟解决方案,
  用设计模式是为了代码重用,让代码易被众人理解,代码可靠性"
  单例设计模式目的是让类创建的对象在系统中只有唯一单实例,
  每一次执行类名() 返回的对象,内存地址是相同的,
  __new__方法;
  用类名() 创对象时,py解释器先用__new__方法为对象分配空间,
  __new__是由object基类提供的内置静态方法,有俩主要作用,
  1在内存中为对象分配空间,   2返回对象的引用,
  py解释器将获得的引用作为第一个参数传递给__init__方法,
  重写__new__方法很固定,一定要 return super().__new__(cls),
  否则解释器得不到以分配空间的对象引用,
  就不会调用对象的初始化方法,静态方法调用时需主动传cls参数
  
  异常;
  概念,程序运行时,若解释器遇到一个错误,会停止程序的执行,
  并提示一些错误信息,这就是异常,
  停止并提示错误信息这个动作,被称之为抛出异常(raise),
  程序开发,很难将所有特殊情况处理得面面俱到,用异常捕获
  可以针对突发事件集中处理,以保证程序稳定性和健壮性,
  捕获异常;
  若认为某些代码的执行不能确定是否正确,
  语法格式;
  try:
      尝试执行的代码
  except:
      出现错误的处理
      
  try(试一试)尝试下方代码,不确定它是否正常执行,
  except(除此之外)若不是,下方编写尝试失败的代码,
  错误类型捕获;
  若遇不同类型异常,且需针对不同做出不同响应,
  此时就需捕获错误类型了,
  语法格式;
  try:
      #尝试执行的代码
      pass
  except 错误类型1:
      #针对错误类型1,对应的代码处理
      pass
  except (错误类型2,错误类型3)
      #针对错误类型2 和 3,对应的代码处理
      pass
  except Exception as 结果:
      print("未知错误 %s"% 结果)
      
  当py解释器抛出异常时,最后一行错误信息的第一个单词,
  就是错误类型,
  捕获未知错误;
  在开发时,未能提前预判到的所有可能出现的错误,即未知错误,
  若希望程序无论出现任何错误,都不会因解释器抛出异常而
  被终止,可以再增加一个except,
  语法格式;
  except Exception as result:
          print("未知错误 %s" % result)
          
  异常捕获完整语法,
  try:
      #尝试执行的代码
      pass
  except 错误类型1:
      #针对错误类型1,对应的代码处理
      pass
  except 错误类型2:
      #针对错误类型2,对应的代码处理
      pass
  except (错误类型3,错误类型4):
      #针对错误类型3 和 4,对应的代码处理
      pass
  except Exception as 结果:
      #打印错误信息
      print(结果)
  else:
      #没有异常才会执行的代码
      pass
  finally:
      #无论是否有异常,都会执行的代码
      print("无论是否有异常,都会执行的代码")
  else只有在没有异常时才会执行,finally无论是否有异常都执行,
  完整语法应用场景,结合实际案例更好理解,先熟悉语法结构,
  异常的传递,
  当函数/方法执行出现异常,会将 异常 传递给调用者,
  若传到主程序,仍没异常处理,程序才会被终止,
  若在主函数中增加异常捕获,被调用的其它函数出现异常都会被
  传到主函数中,这就无需再增加大量异常捕获代码,确保整洁性,
  抛出 raise 异常,
  除了代码出错py解释器会抛出异常外,还可根据应用程序特有的
  业务需求主动抛出异常,
  抛出异常,
  py中提供了一个 Exception 异常类,开发中若有使用它的需求
  创建一个 Exception 的对象,用 raise 关键字抛出异常对象,
  
  模块;
  它是py程序架构的一个核心概念,
  每一个以 .py 结尾的源码文件都是一模块,模块名同样是个标识符,需符合命名规则,
  在模块中定义的全局变量,函数,类都是提供给外界直接使用的工具,
  模块就像工具包,想使用其中工具,需先导入此模块,
  两种导入方式,导入时,每个导入应独占一行,
  1 import导入,
  语法;
  import 模块名1,模块名2
  import 模块名1
  import 模块名2
  导入后,用 模块名. 调用模块中的工具---全局变量,函数,类,
  使用 as 指定模块的别名,若模块名太长,用as起个别的名字, 
  语法;
  import 模块名1 as 模块别名
  模块别名应符合大驼峰命名法,
  2 from...import 导入,
  若希望从某模块只导入部分工具,即可用此方式,
  import 模块名 是一次性导入所有工具,并用 模块名/别名 访问,
  语法;
  #从 模块 导入某一工具
  from 模块名1 import 工具名
  导入后,无需用 模块名.  ,可直接用模块提供的工具,
  若有两模块存在同名函数,后导入的会覆盖先导入的,
  import语句应置于代码的顶部,能及时发现冲突,
  并可用as关键字给有冲突工具名起别名,
  from 模块名1 import 工具名 as 起别名
  
  from...import *
  #从 模块 导入所有工具,并可直接使用 函数/全局变量/类,
  from 模块名1 import *
  这种方式不推荐,因重名不会有任何提示,不好排查,
  
  模块的搜索顺序[扩展],
  py解释器在导入模块时,会搜索当前目录指定模块名的文件,
  若有直接导入,若没有再搜索系统目录,因此,开发时文件起名
  不要和系统的模块文件重名,否则,解释器会优先加载自定义的
  而不会优先加载系统自带的,
  py中,每个模块都有内置属性__file__可查看模块完整路径,
  
  原则-每一个文件都应该是可以被导入的,
  在实际开发中,每个模块都是独立开发的,大多都有专人负责,
  开发者通常会在模块下方增加一些测试代码,仅在模块内用,
  导入到其它文件中不需要执行,
  __name__属性,可以做到仅在测试时被运行,被导入时不执行,
  __name__是py的内置属性,记录着一个字符串,
  __name__属性兼顾测试和导入两种模式,
  若被其它文件导入,它是模块名,若是当前执行程序,它是__main__
  文件中,所有没有任何缩进的代码都会被执行一遍,
  语法;
  #导入模块
  #定义全局变量
  #定义类
  #定义函数
  
  #在代码的最下方
  def main():
        #.......
        pass
  #根据__name__判断是否执行下方代码
  if __name__ == "__main__":
        main()
  
  包;
  包是一个包含多个模块的特殊目录,目录下有一个
  特殊文件__init__.py
  包名的命名方式和变量名一致,
  用 import 包名 可一次性导入包中所有模块,
  
  __init__.py;
  要在外界使用 包 中的模块,需要在__init__.py中
  指定对外界提供的模块列表,
  语法;
  #从 当前目录 导入 模块列表
  from . import 模块名1
  from . import 模块名2
  
  发布模块;
  若希望自己开发的模块分享给他人,步骤如下,
  制作模块发布压缩包,
  1创建setup.py
  from distutils.core import setup
  #这个函数的参数是多值参数,是个字典,键必须用英文,呵呵...
  setup(名字 = "消息", #包名
            版本 = "0.1", #版本号
            描述信息 = "发送和接收消息模块", #描述信息
            长描述 = "完整的发送和接收消息模块", #完整描述
            著作 = "学习者", #署名作者
            著作邮箱 = "学习者@学习者.com", #作者邮箱
            主页 = "www.学习者.com", #作者主页
            py模块 = ["消息.发送消息,"
                            "消息.接收消息"])
                            
  2构建模块
  python3 setup.py build
  
  3生成发布压缩包
  python3 setup.py sdist
  
  欲制作哪个版本的模块,就用哪个版本的解释器,
  安装模块,
  解压,tar -zxvf 包名.tar.gz
  sudo python3 setup.py install
  卸载模块,
  直接从安装目录删除即可,
  进入安装路径目录下,sudo rm -r 包名*
  pip安装第三方模块,
  通常是指知名的第三方团队开发的,被程序员广泛使用的
  py包/模块,如pygame就是一套成熟的游戏开发模块,
  pip是一个现代的,通用的py包管理工具,提供了对py包的
  查找,下载,安装,卸载等功能,
  安装和卸载命令如下,
  #将模块安装到python 2.x 环境
  sudo pip install pygame
  sudo pip uninstall pygame
  #将模块安装到python 3.x 环境
  sudo pip3 install pygame
  sudo pip3 uninstall pygame
  
  在Linux下安装ipython
  sudo apt install ipython
  sudo apt install ipython3
  
  文件;
  概念和作用;
  计算机的文件,就是存储在长期存储设备上的一段数据,
  长期存储设备有:硬盘,优盘,移动硬,光盘,磁带...
  作用是将数据长期保存需要时使用,
  文件的存储方式,
  在计算机中,文件是以二进制的方式保存在磁盘上的,
  日常通常分两种类型,文本文件和二进制文件,
  文本文件可用文本编辑器查看,本质上以二进制存储文本数据,
  二进制文件保存的内容不是供人阅读,而是提供给其它软件用,
  如图片,音频,视频等,二进制文件不能直接用文本编辑器查看,
  文件的基本操作,
  操作文件的流程非常固定,共三步,
  1打开文件,   2读-写文件_读进内存写入存储设备,   3关闭文件,
  操作文件的函数/方法,
  py中操作文件的1个函数3个方法,
  open函数打开文件,返回文件对象,
  read/write/close三方法需通过文件对象调用,
  
  read方法-读取文件,
  open函数的第一个参数是要打开的文件名,区分大小写,
  若文件存在,返回文件操作对象,若不存在,则抛出异常,
  read方法可一次性读入并返回文件的所有内容,
  close方法负责关闭文件,若忘记关闭文件,会浪费系统资源,
  且影响到后续对文件的访问,方法执行后,会把文件指针
  移动到文件的末尾,
  在开发中,通常会先编写打开和关闭的代码,再编写中间针对
  文件的读/写操作,
  语法;
  #打开-注意大小写,
  file = open("文件名",encoding="UTF-8")
  #读取
  text = file.read()
  print(text)
  #关闭
  file.close()
  
  注,关于执行时字符编码错误问题,
  不同操作系统平台有不同问题症状,
  注意编码格式在各文件的统一,最好在打开文件的时候指定编码,
  如:文件 = open("READme",encoding="UTF-8")
  
  文件指针,
  标记从哪个位置开始读取数据,第一次打开文件时,通常文件指针
  会指向文件的开始位置,当执行了read方法后,文件指针会
  移动到读取内容的末尾,
  默认情况移动到文件末尾,
  若用read方法读取过一次,再读便读不出内容,
  因为文件指针已被移到末尾.
  
  打开文件的方式,
  open函数默认以只读打开文件,且返回文件对象,
  语法;
  f = open("文件名","访问方式")
  访问方式,只读:r,   只写:w,   读写:r+ w+ a+,   追加:a,
  频繁移动文件指针,读写效率低下,只读只写是开发时常用方式,
  
  按行读取文件内容,
  read方法默认会把文件的所有内容一次性读取到内存,
  若文件太大,对内存的占用会非常严重,
  readline方法可一次只读一行,方法执行后,会把文件指针
  移动到下一行,准备再次读取,
  小文件复制,打开,读取全部内容,写入,
  大文件复制,打开,逐行读取内容,写入.
  
  文件/目录的常用管理操作,
  若希望在程序中实现 创建,重命名,改变路径,查看目录内容,.......
  等管理操作,需要导入os模块,
  文件操作,
  os.rename(原文件名,目标文件名)       os.remove(文件名)
  目录操作,
  os.listdir(目录名) os.mkdir(目录名) os.rmdir(目录名) 
  os.getcwd() os.chdir(目标目录) os.path.isdir(文件路径) 
  文件与目录操作,都支持相对路径和绝对路径,
  
  文本文件的编码格式,
  文本文件中每一个字符到底是怎样用二进制来表示的呢?
  文本文件存储的内容是基于字符编码的文件,
  py2默认用ASCII编码,   py3默认用UTF-8编码,
  ASCII编码,
  256个字符,每个在内存中占用1个字节空间,
  1字节=8个二进制位,其排列组合就有2X8=256种组合,
  每一个组合存储一个ASCII字符,
  UTF-8编码,
  用1到6个字节存储一个UTF-8字符,涵盖人类几乎所有文字字符,
  大多数汉字使用3个字节存储,
  UTF-8是unicode编码在存储器中的二进制表示,
  
  py2中如何使用中文汉字汉语,
  在py2源码文件的第一行增加以下代码,解释器以指定的
  编码方式来处理py源文件中的字符串,
  # *-* coding:utf8 *-*
  # coding=utf8
  解释:unicode字符串在py2中即使指定了文件使用UTF-8的
  编码格式,但在遍历字符串时,仍然会以字节为单位遍历,
  若要正确的遍历字符串,在定义时,需在字符串的引号前,
  增加一个小写字母u,告诉解释器这是一个unicode字符串,
  
  eval函数;
  eval() 函数十分强大-将字符串当成有效表达式求值返回结果,
  #基本的数学计算
  In [1]: eval("1 + 1")
  Out[1]: 2
  #字符串重复
  In [2]: eval("'*' * 10")
  Out[2]: '**********'
  #将字符串转换成列表
  In [3]: type(eval("[1,2,3,4,5]"))
  Out[3]: list
  #将字符串转换成字典
  In [4]: type(eval("{'姓名':'小明','年龄':18}"))
  Out[4]: dict
  不要滥用eval,不要用它直接转换input的结果,
  __import__('os').system('ls') 
  等价于
  import  os
  os.system("终端命令")  


10项目实战-飞机大战;
  强化面向对象编程程序设计能力,
  体验使用pygame模块进行游戏开发,
  pygame为设计游戏的py模块.
  
  目标;
  项目准备, -新建项目,新建py文件,导入游戏素材,
  用pygame创建图形窗口,
  理解图像并实现图像绘制,
  理解游戏循环和游戏时钟,
  理解精灵和精灵组,

  将图片素材绘制到游戏窗口上,
  游戏的初始化和退出,坐标系,创建主窗口,简单地游戏循环,
  pygame.init() → 游戏代码 → pygame.quit() 
  
  坐标系;
  原点在左上角(0,0) ,x轴水平方向 向右,递增,
  y轴垂直方向 向下,递增,
  游戏中所有可见的元素都以矩形区域描述位置,
  一个矩形区域有四个要素:(x,y) (width,height) 
  pygame专门提供一个类pygame.Rect描述矩形区域,
  Rect(x,y,width,height) -> rect 
  
  创建游戏主窗口;
  模块pygame.display用于创建-管理游戏窗口,
  pygame.display.set_mode()  pygame.display.update() 
  #创建游戏主窗口-用变量接收set_mode方法返回值,
  屏幕 = pygame.display.set_mode((480,700)) 
  游戏循环就是一个无限循环,程序启动后,不会立即退出,
  
  理解 图像 并实现图像绘制,
  在游戏中能看到的游戏元素大多是图像,图像文件始终存在磁盘,
  若要使用,需加载到内存,三步骤,
  1用pygame.image.load() 加载图像数据,
  2用 游戏屏幕 对象,调用blit方法将图像绘制到指定位置,
  3调用pygame.display.update()更新整个屏幕的显示,
  
  理解游戏循环 和 游戏时钟,
  游戏中的动画实现原理,跟电影的原理类似,
  游戏中的动画效果,本质上是快速在屏幕上绘制图像,
  电影是将多张静止的电影胶片连续快速地播放,产生连贯视觉效
  一般在电脑上每秒绘制60次,就能实现连续高品质动画效果,
  每次绘制的结果被称为 帧 Frame,
  游戏的两个组成部分,
  游戏循环的开始意味着游戏正式开始,
  游戏初始化(设置游戏窗口,绘制图像初始位置,设置游戏时钟) →
  游戏循环(设置刷新帧率,检测用户交互,更新所有图像位置,
                  更新屏幕显示)
  游戏循环的作用,
  1保证游戏不会直接退出,2变化图像位置-动画效果,每隔1/60秒
  移动一下所有图像的位置,调用update()方法更新屏幕显示,
  3检测用户交互-按键,鼠标等...
  
  游戏时钟;
  pygame.time.Clock类可方便地设置绘制速度-刷新帧率,
  使用方法;
  1在游戏初始化创建一个时钟对象,
  2在游戏循环中让时钟对象调用tick(帧率) 方法,
  tick方法会根据上次被调用的时间,自动设置循环中的延时,
  
  在游戏循环中监听事件,
  事件 event,即游戏启动后,用户针对游戏所做的操作,
  如:点击关闭按钮,点击鼠标,按下键盘...
  监听,
  在游戏循环中,判断用户具体的操作,只有捕获到用户具体的操作
  才能有针对性地做出响应,
  代码实现,
  pygame.event.get() 可以获得用户当前所做动作的事件列表
  用户可以同一时间做很多事情,这段代码非常固定,几乎所有
  pygame游戏都大同小异,
  
  pygame中的高级类,精灵和精灵组,
  精灵可理解为一个对象,包含图像数据和显示位置,
  精灵就像小弟,精灵组就像大哥,小弟有很多,组成很多堂口,
  好处就是,开发者向大哥-精灵组发出命令,它会利用组织力在
  组织内把命令传给各堂口的各小弟-精灵处,
  这样就不必要给每个小弟讲解一遍命令,而只需指示大哥即可,
  
  使用常量代替固定的数值,
  常量-不变化的量,变量-可以变化的量
  若在开发时需使用固定的数值,应该使用常量,保证可维护性,
  
  使用定时器添加敌机,
  pygame.time.set_timer()添加定时器,
  所谓定时器,就是每隔一段时间,去执行一些动作,
  